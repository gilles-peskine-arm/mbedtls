/* BEGIN_HEADER */
#include <stdint.h>

static int all_subsystems_are_initialized( void )
{
    return( mbedtls_psa_crypto_is_subsystem_initialized(
                MBEDTLS_PSA_CRYPTO_ALL_SUBSYSTEMS ) );
}

static int no_subsystems_are_initialized( void )
{
    mbedtls_psa_crypto_subsystem_index_t i;
    for( i = 0; i < MBEDTLS_PSA_CRYPTO_SUBSYSTEM_COUNT; i++ )
    {
        TEST_ASSERT( ! mbedtls_psa_crypto_is_subsystem_initialized( 1 << i ) );
    }
    return( 1) ;

exit:
    return( 0 );
}

/* Assume that the key store is initialized, but the random generator is not.
 * Check that a cipher mechanism with IV behaves as expected. */
static int test_symmetric_key_without_random( psa_key_type_t key_type,
                                              psa_algorithm_t alg )
{
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    int ok = 0;

    psa_set_key_type( &attributes, key_type );
    psa_set_key_algorithm( &attributes, alg );
    psa_set_key_usage_flags( &attributes,
                             PSA_KEY_USAGE_ENCRYPT |
                             PSA_KEY_USAGE_DECRYPT );
    const uint8_t key_data[32] = "KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK";
    PSA_ASSERT( psa_import_key( &attributes,
                                key_data, sizeof( key_data ),
                                &key ) );

    uint8_t plaintext[16] = "This is a sample";
    uint8_t ciphertext[32] = "[[[[IV  here]]]]CIPHERTEXT!";
    size_t length;
    PSA_ASSERT( psa_cipher_decrypt( key, alg,
                                    ciphertext, sizeof( ciphertext ),
                                    plaintext, sizeof( plaintext ),
                                    &length ) );

    /* Should fail to generate an IV */
    TEST_EQUAL( PSA_ERROR_BAD_STATE,
                psa_cipher_encrypt( key, alg,
                                    plaintext, sizeof( plaintext ),
                                    ciphertext, sizeof( ciphertext ),
                                    &length ) );

    PSA_ASSERT( psa_destroy_key( key ) );
    psa_reset_key_attributes( &attributes );

    ok = 1;

exit:
    psa_reset_key_attributes( &attributes );
    psa_destroy_key( key );
    return( ok );
}

/* Assume that the key store is initialized, but the random generator is not.
 * Check that various cryptographic operations behave as expected.
 *
 * This function currently covers a representative set of algorithms.
 * It does not attempt systematic coverage.
 */
static int test_with_keys_without_random( void )
{
    /* IV generation requires random, but decryption doesn't. */
#if defined(PSA_WANT_KEY_TYPE_AES) && defined(PSA_WANT_ALG_CTR)
    if( ! test_symmetric_key_without_random( PSA_KEY_TYPE_AES,
                                             PSA_ALG_CTR ) )
        return( 0 );
#endif
#if defined(PSA_WANT_KEY_TYPE_CAMELLIA) && defined(PSA_WANT_ALG_CTR)
    if( ! test_symmetric_key_without_random( PSA_KEY_TYPE_CAMELLIA,
                                             PSA_ALG_CTR ) )
        return( 0 );
#endif
    /* Don't bother figuring out exactly in which configurations the function
     * is unused. */
    (void) test_symmetric_key_without_random;

    /* TODO: check that signature verification is possible. */
    /* TODO: check that signing with a built-in implementation that uses
     * blinding is rejected. */
    /* TODO: check that asymmetric encryption is rejected. */

    return( 1 );
}

/* Check that the availability of API functions is coherent with
 * the claims from mbedtls_psa_crypto_is_subsystem_initialized(). */
static int subsystems_are_coherent( void )
{
    int ok = 0;
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    mbedtls_svc_key_id_t key = MBEDTLS_SVC_KEY_ID_INIT;
    const uint8_t key_material[1] = {'K'};
    uint8_t rnd1[16] = {0}, rnd2[16] = {0};

    /* Communication: nothing to check since the tests are calling the library
     * directly. */

    psa_set_key_type( &attributes, PSA_KEY_TYPE_RAW_DATA );
    if( mbedtls_psa_crypto_is_subsystem_initialized(
            PSA_CRYPTO_SUBSYSTEM_KEYS ) )
    {
        PSA_ASSERT( psa_import_key( &attributes, key_material, 1, &key ) );
        psa_reset_key_attributes( &attributes );
        PSA_ASSERT( psa_get_key_attributes( key, &attributes ) );
        TEST_EQUAL( psa_get_key_type( &attributes ), PSA_KEY_TYPE_RAW_DATA );
        TEST_EQUAL( psa_get_key_bits( &attributes ), 8 );
        PSA_ASSERT( psa_destroy_key( key ) );
        key = MBEDTLS_SVC_KEY_ID_INIT;
    }
    else
    {
        TEST_EQUAL( psa_import_key( &attributes, key_material, 1, &key ),
                    PSA_ERROR_BAD_STATE );
        TEST_EQUAL( psa_get_key_attributes( key, &attributes ),
                    PSA_ERROR_BAD_STATE );
    }
    psa_reset_key_attributes( &attributes );

    /* Gray box testing: Mbed TLS currently initializes storage access
     * together with the key store in memory. */
    TEST_EQUAL( mbedtls_psa_crypto_is_subsystem_initialized(
                    PSA_CRYPTO_SUBSYSTEM_KEYS ),
                mbedtls_psa_crypto_is_subsystem_initialized(
                    PSA_CRYPTO_SUBSYSTEM_STORAGE ) );

    /* TODO: PSA_CRYPTO_SUBSYSTEM_ACCELERATORS */
    /* Need to find an accelerated algorithm and try to use it. */
    /* Also arrange a white-box check when using a test driver. */

    /* TODO: PSA_CRYPTO_SUBSYSTEM_SECURE_ELEMENTS */
    /* Need to find a secure element location and try to use it. */
    /* Also arrange a white-box check when using a test driver. */

    psa_set_key_type( &attributes, PSA_KEY_TYPE_RAW_DATA );
    psa_set_key_bits( &attributes, 8 );
    if( mbedtls_psa_crypto_is_subsystem_initialized(
            PSA_CRYPTO_SUBSYSTEM_RANDOM ) )
    {
        PSA_ASSERT( psa_generate_random( rnd1, sizeof( rnd1 ) ) );
        PSA_ASSERT( psa_generate_random( rnd2, sizeof( rnd2 ) ) );
        /* If the random generator is working properly, the chances of
         * getting the same 16 bytes twice are negligible. */
        TEST_ASSERT( memcmp( rnd1, rnd2, sizeof( rnd1 ) ) != 0 );

        if( mbedtls_psa_crypto_is_subsystem_initialized(
                PSA_CRYPTO_SUBSYSTEM_KEYS ) )
        {
            PSA_ASSERT( psa_generate_key( &attributes, &key ) );
        }
    }
    else
    {
        TEST_EQUAL( psa_generate_random( rnd1, sizeof( rnd1 ) ),
                    PSA_ERROR_BAD_STATE );
        if( mbedtls_psa_crypto_is_subsystem_initialized(
                PSA_CRYPTO_SUBSYSTEM_KEYS ) )
        {
            TEST_EQUAL( psa_generate_key( &attributes, &key ),
                        PSA_ERROR_BAD_STATE );
            if( ! test_with_keys_without_random( ) )
                goto exit;
        }
    }
    psa_reset_key_attributes( &attributes );

    /* Gray box testing: Mbed TLS currently initializes built-in keys
     * together with the key store in memory. */
    TEST_EQUAL( mbedtls_psa_crypto_is_subsystem_initialized(
                    PSA_CRYPTO_SUBSYSTEM_KEYS ),
                mbedtls_psa_crypto_is_subsystem_initialized(
                    PSA_CRYPTO_SUBSYSTEM_BUILTIN_KEYS ) );

    ok = 1;

exit:
    psa_reset_key_attributes( &attributes );
    psa_destroy_key( key );
    return( ok );
}

/* Some tests in this module configure entropy sources. */
#include "psa_crypto_invasive.h"

#include "mbedtls/entropy.h"
#include "entropy_poll.h"

#define ENTROPY_MIN_NV_SEED_SIZE                                        \
    MAX(MBEDTLS_ENTROPY_MIN_PLATFORM, MBEDTLS_ENTROPY_BLOCK_SIZE)

#include "psa_crypto_random_impl.h"
#if defined(MBEDTLS_PSA_HMAC_DRBG_MD_TYPE)
/* PSA crypto uses the HMAC_DRBG module. It reads from the entropy source twice:
 * once for the initial entropy and once for a nonce. The nonce length is
 * half the entropy length. For SHA-256, SHA-384 or SHA-512, the
 * entropy length is 256 per the documentation of mbedtls_hmac_drbg_seed(),
 * and PSA crypto doesn't support other hashes for HMAC_DRBG. */
#define ENTROPY_NONCE_LEN ( 256 / 2 )
#else
/* PSA crypto uses the CTR_DRBG module. In some configurations, it needs
 * to read from the entropy source twice: once for the initial entropy
 * and once for a nonce. */
#include "mbedtls/ctr_drbg.h"
#define ENTROPY_NONCE_LEN MBEDTLS_CTR_DRBG_ENTROPY_NONCE_LEN
#endif

#if !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG)

typedef struct
{
    size_t threshold; /* Minimum bytes to make mbedtls_entropy_func happy */
    size_t max_steps;
    size_t *length_sequence;
    size_t step;
} fake_entropy_state_t;
static int fake_entropy_source( void *state_arg,
                                unsigned char *output, size_t len,
                                size_t *olen )
{
    fake_entropy_state_t *state = state_arg;
    size_t i;

    if( state->step >= state->max_steps )
        return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );

    *olen = MIN( len, state->length_sequence[state->step] );
    for( i = 0; i < *olen; i++ )
        output[i] = i;
    ++state->step;
    return( 0 );
}

#define ENTROPY_SOURCE_PLATFORM                 0x00000001
#define ENTROPY_SOURCE_TIMING                   0x00000002
#define ENTROPY_SOURCE_HARDWARE                 0x00000004
#define ENTROPY_SOURCE_NV_SEED                  0x00000008
#define ENTROPY_SOURCE_FAKE                     0x40000000

static uint32_t custom_entropy_sources_mask;
static fake_entropy_state_t fake_entropy_state;

/* This is a modified version of mbedtls_entropy_init() from entropy.c
 * which chooses entropy sources dynamically. */
static void custom_entropy_init( mbedtls_entropy_context *ctx )
{
    ctx->source_count = 0;
    memset( ctx->source, 0, sizeof( ctx->source ) );

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &ctx->mutex );
#endif

    ctx->accumulator_started = 0;
#if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    mbedtls_sha512_init( &ctx->accumulator );
#else
    mbedtls_sha256_init( &ctx->accumulator );
#endif

#if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)
    if( custom_entropy_sources_mask & ENTROPY_SOURCE_PLATFORM )
        mbedtls_entropy_add_source( ctx, mbedtls_platform_entropy_poll, NULL,
                                    MBEDTLS_ENTROPY_MIN_PLATFORM,
                                    MBEDTLS_ENTROPY_SOURCE_STRONG );
#endif
#if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    if( custom_entropy_sources_mask & ENTROPY_SOURCE_HARDWARE )
        mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,
                                    MBEDTLS_ENTROPY_MIN_HARDWARE,
                                    MBEDTLS_ENTROPY_SOURCE_STRONG );
#endif
#if defined(MBEDTLS_ENTROPY_NV_SEED)
    if( custom_entropy_sources_mask & ENTROPY_SOURCE_NV_SEED )
    {
        mbedtls_entropy_add_source( ctx, mbedtls_nv_seed_poll, NULL,
                                    MBEDTLS_ENTROPY_BLOCK_SIZE,
                                    MBEDTLS_ENTROPY_SOURCE_STRONG );
        ctx->initial_entropy_run = 0;
    }
    else
    {
        /* Skip the NV seed even though it's compiled in. */
        ctx->initial_entropy_run = 1;
    }
#endif

    if( custom_entropy_sources_mask & ENTROPY_SOURCE_FAKE )
        mbedtls_entropy_add_source( ctx,
                                    fake_entropy_source, &fake_entropy_state,
                                    fake_entropy_state.threshold,
                                    MBEDTLS_ENTROPY_SOURCE_STRONG );
}

#endif /* !defined(MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) */

/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PSA_CRYPTO_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE depends_on:MBEDTLS_ENTROPY_NV_SEED:!MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
void create_nv_seed( )
{
    static unsigned char seed[ENTROPY_MIN_NV_SEED_SIZE];
    TEST_ASSERT( mbedtls_nv_seed_write( seed, sizeof( seed ) ) >= 0 );
}
/* END_CASE */

/* BEGIN_CASE */
void init_deinit( int count )
{
    psa_status_t status;
    int i;
    for( i = 0; i < count; i++ )
    {
        status = psa_crypto_init( );
        PSA_ASSERT( status );
        TEST_ASSERT( all_subsystems_are_initialized( ) );
        TEST_ASSERT( subsystems_are_coherent( ) );

        status = psa_crypto_init( );
        PSA_ASSERT( status );
        TEST_ASSERT( all_subsystems_are_initialized( ) );
        TEST_ASSERT( subsystems_are_coherent( ) );

        PSA_DONE( );
        TEST_ASSERT( no_subsystems_are_initialized( ) );
        TEST_ASSERT( subsystems_are_coherent( ) );
    }
}
/* END_CASE */

/* BEGIN_CASE */
void deinit_without_init( int count )
{
    int i;
    for( i = 0; i < count; i++ )
    {
        PSA_ASSERT( psa_crypto_init( ) );
        TEST_ASSERT( all_subsystems_are_initialized( ) );
        TEST_ASSERT( subsystems_are_coherent( ) );

        PSA_DONE( );
        TEST_ASSERT( subsystems_are_coherent( ) );
        TEST_ASSERT( no_subsystems_are_initialized( ) );
    }

    PSA_DONE( );
    TEST_ASSERT( subsystems_are_coherent( ) );
    TEST_ASSERT( no_subsystems_are_initialized( ) );
}
/* END_CASE */

/* BEGIN_CASE */
void subsystem_init( int subsystems )
{
    TEST_EQUAL( subsystems == 0,
                mbedtls_psa_crypto_is_subsystem_initialized( subsystems ) );

    mbedtls_test_set_step( 1 );
    PSA_ASSERT( psa_crypto_init_subsystem( subsystems ) );
    TEST_EQUAL( 1, mbedtls_psa_crypto_is_subsystem_initialized( subsystems ) );
    TEST_ASSERT( subsystems_are_coherent( ) );

    /* A second initialization should be a no-op */
    mbedtls_test_set_step( 2 );
    PSA_ASSERT( psa_crypto_init_subsystem( subsystems ) );
    TEST_EQUAL( 1, mbedtls_psa_crypto_is_subsystem_initialized( subsystems ) );
    TEST_ASSERT( subsystems_are_coherent( ) );

    mbedtls_test_set_step( 3 );
    PSA_DONE( );
    TEST_ASSERT( no_subsystems_are_initialized( ) );
    TEST_EQUAL( subsystems == 0,
                mbedtls_psa_crypto_is_subsystem_initialized( subsystems ) );
    TEST_ASSERT( subsystems_are_coherent( ) );
}
/* END_CASE */

/* BEGIN_CASE */
void subsystem_init_invalid( int subsystem )
{
    TEST_EQUAL( 0, mbedtls_psa_crypto_is_subsystem_initialized( subsystem ) );
    TEST_EQUAL( psa_crypto_init_subsystem( subsystem ),
                PSA_ERROR_INVALID_ARGUMENT );
    TEST_EQUAL( 0, mbedtls_psa_crypto_is_subsystem_initialized( subsystem ) );
    TEST_ASSERT( no_subsystems_are_initialized( ) );
    TEST_ASSERT( subsystems_are_coherent( ) );
}
/* END_CASE */

/* BEGIN_CASE */
void validate_module_init_generate_random( int count )
{
    psa_status_t status;
    uint8_t random[10] = { 0 };
    int i;
    for( i = 0; i < count; i++ )
    {
        status = psa_crypto_init( );
        PSA_ASSERT( status );
        PSA_DONE( );
    }
    status = psa_generate_random( random, sizeof( random ) );
    TEST_EQUAL( status, PSA_ERROR_BAD_STATE );
}
/* END_CASE */

/* BEGIN_CASE */
void validate_module_init_key_based( int count )
{
    psa_status_t status;
    uint8_t data[10] = { 0 };
    psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;
    mbedtls_svc_key_id_t key = mbedtls_svc_key_id_make( 0xdead, 0xdead );
    int i;

    for( i = 0; i < count; i++ )
    {
        status = psa_crypto_init( );
        PSA_ASSERT( status );
        PSA_DONE( );
    }
    psa_set_key_type( &attributes, PSA_KEY_TYPE_RAW_DATA );
    status = psa_import_key( &attributes, data, sizeof( data ), &key );
    TEST_EQUAL( status, PSA_ERROR_BAD_STATE );
    TEST_ASSERT( mbedtls_svc_key_id_is_null( key ) );
}
/* END_CASE */

/* BEGIN_CASE depends_on:!MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
void custom_entropy_sources( int sources_arg, int expected_init_status_arg )
{
    psa_status_t expected_init_status = expected_init_status_arg;
    uint8_t random[10] = { 0 };

    custom_entropy_sources_mask = sources_arg;
    PSA_ASSERT( mbedtls_psa_crypto_configure_entropy_sources(
                    custom_entropy_init, mbedtls_entropy_free ) );

    TEST_EQUAL( psa_crypto_init( ), expected_init_status );
    if( expected_init_status != PSA_SUCCESS )
        goto exit;

    PSA_ASSERT( psa_generate_random( random, sizeof( random ) ) );

exit:
    PSA_DONE( );
}
/* END_CASE */

/* BEGIN_CASE depends_on:!MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
void fake_entropy_source( int threshold,
                          int amount1,
                          int amount2,
                          int amount3,
                          int amount4,
                          int expected_init_status_arg )
{
    psa_status_t expected_init_status = expected_init_status_arg;
    uint8_t random[10] = { 0 };
    size_t lengths[4];

    fake_entropy_state.threshold = threshold;
    fake_entropy_state.step = 0;
    fake_entropy_state.max_steps = 0;
    if( amount1 >= 0 )
        lengths[fake_entropy_state.max_steps++] = amount1;
    if( amount2 >= 0 )
        lengths[fake_entropy_state.max_steps++] = amount2;
    if( amount3 >= 0 )
        lengths[fake_entropy_state.max_steps++] = amount3;
    if( amount4 >= 0 )
        lengths[fake_entropy_state.max_steps++] = amount4;
    fake_entropy_state.length_sequence = lengths;

    custom_entropy_sources_mask = ENTROPY_SOURCE_FAKE;
    PSA_ASSERT( mbedtls_psa_crypto_configure_entropy_sources(
                    custom_entropy_init, mbedtls_entropy_free ) );

    TEST_EQUAL( psa_crypto_init( ), expected_init_status );
    if( expected_init_status != PSA_SUCCESS )
        goto exit;

    PSA_ASSERT( psa_generate_random( random, sizeof( random ) ) );

exit:
    PSA_DONE( );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_ENTROPY_NV_SEED:!MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG */
void entropy_from_nv_seed( int seed_size_arg,
                           int expected_init_status_arg )
{
    psa_status_t expected_init_status = expected_init_status_arg;
    uint8_t random[10] = { 0 };
    uint8_t *seed = NULL;
    size_t seed_size = seed_size_arg;

    ASSERT_ALLOC( seed, seed_size );
    TEST_ASSERT( mbedtls_nv_seed_write( seed, seed_size ) >= 0 );

    custom_entropy_sources_mask = ENTROPY_SOURCE_NV_SEED;
    PSA_ASSERT( mbedtls_psa_crypto_configure_entropy_sources(
                    custom_entropy_init, mbedtls_entropy_free ) );

    TEST_EQUAL( psa_crypto_init( ), expected_init_status );
    if( expected_init_status != PSA_SUCCESS )
        goto exit;

    PSA_ASSERT( psa_generate_random( random, sizeof( random ) ) );

exit:
    mbedtls_free( seed );
    PSA_DONE( );
}
/* END_CASE */
