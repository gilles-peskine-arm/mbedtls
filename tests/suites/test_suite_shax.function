/* BEGIN_HEADER */
#include "mbedtls/sha1.h"
#include "mbedtls/sha256.h"
#include "mbedtls/sha512.h"
#include "mbedtls/sha3.h"
/* END_HEADER */

/* BEGIN_CASE depends_on:MBEDTLS_SHA1_C */
void mbedtls_sha1( data_t * src_str, data_t * hex_hash_string )
{
    unsigned char output[41];

    memset(output, 0x00, 41);


    TEST_ASSERT( mbedtls_sha1_ret( src_str->x, src_str->len, output ) == 0 );

    TEST_ASSERT( hexcmp( output, hex_hash_string->x, 20, hex_hash_string->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C */
void sha224( data_t * src_str, data_t * hex_hash_string )
{
    unsigned char output[57];

    memset(output, 0x00, 57);


    TEST_ASSERT( mbedtls_sha256_ret( src_str->x, src_str->len, output, 1 ) == 0 );

    TEST_ASSERT( hexcmp( output, hex_hash_string->x, 28, hex_hash_string->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C */
void mbedtls_sha256( data_t * src_str, data_t * hex_hash_string )
{
    unsigned char output[65];

    memset(output, 0x00, 65);


    TEST_ASSERT( mbedtls_sha256_ret( src_str->x, src_str->len, output, 0 ) == 0 );

    TEST_ASSERT( hexcmp( output, hex_hash_string->x, 32, hex_hash_string->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C */
void sha384( data_t * src_str, data_t * hex_hash_string )
{
    unsigned char output[97];

    memset(output, 0x00, 97);


    TEST_ASSERT( mbedtls_sha512_ret( src_str->x, src_str->len, output, 1 ) == 0 );

    TEST_ASSERT( hexcmp( output, hex_hash_string->x, 48, hex_hash_string->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C */
void mbedtls_sha512( data_t * src_str, data_t * hex_hash_string )
{
    unsigned char output[129];

    memset(output, 0x00, 129);


    TEST_ASSERT( mbedtls_sha512_ret( src_str->x, src_str->len, output, 0 ) == 0 );

    TEST_ASSERT( hexcmp( output, hex_hash_string->x, 64, hex_hash_string->len ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_224( char *hex_src_string, char *hex_hash_string )
{
    unsigned char src_str[10000];
    unsigned char hash_str[10000];
    unsigned char output[129];
    int src_len;

    memset(src_str, 0x00, 10000);
    memset(hash_str, 0x00, 10000);
    memset(output, 0x00, 129);

    src_len = unhexify( src_str, hex_src_string );

    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_224, output);
    hexify( hash_str, output, 28 );

    TEST_ASSERT( strcmp( (char *) hash_str, hex_hash_string ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_256( char *hex_src_string, char *hex_hash_string )
{
    unsigned char src_str[10000];
    unsigned char hash_str[10000];
    unsigned char output[129];
    int src_len;

    memset(src_str, 0x00, 10000);
    memset(hash_str, 0x00, 10000);
    memset(output, 0x00, 129);

    src_len = unhexify( src_str, hex_src_string );

    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_256, output);
    hexify( hash_str, output, 32 );

    TEST_ASSERT( strcmp( (char *) hash_str, hex_hash_string ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_384( char *hex_src_string, char *hex_hash_string )
{
    unsigned char src_str[10000];
    unsigned char hash_str[10000];
    unsigned char output[129];
    int src_len;

    memset(src_str, 0x00, 10000);
    memset(hash_str, 0x00, 10000);
    memset(output, 0x00, 129);

    src_len = unhexify( src_str, hex_src_string );

    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_384, output);
    hexify( hash_str, output, 48 );

    TEST_ASSERT( strcmp( (char *) hash_str, hex_hash_string ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_512( char *hex_src_string, char *hex_hash_string )
{
    unsigned char src_str[10000];
    unsigned char hash_str[10000];
    unsigned char output[129];
    int src_len;

    memset(src_str, 0x00, 10000);
    memset(hash_str, 0x00, 10000);
    memset(output, 0x00, 129);

    src_len = unhexify( src_str, hex_src_string );

    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_512, output);
    hexify( hash_str, output, 64 );

    TEST_ASSERT( strcmp( (char *) hash_str, hex_hash_string ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_224_streaming( char *hex_src_string )
{
    mbedtls_sha3_context ctx;
    unsigned char reference_hash[129];
    unsigned char hash[129];
    unsigned char src_str[10000];
    size_t i;
    size_t chunk_size;
    size_t remaining;
    size_t src_len;
    
    memset(src_str, 0x00, 10000);
    memset(hash, 0x00, 129);
    memset(reference_hash, 0x00, 129);
    
    src_len = unhexify( src_str, hex_src_string );
    
    /* Generate a reference hash */
    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_224, reference_hash );
    
    /* Repeat each test with increasingly-sized data chunks 
     * E.g. start by processing bytes individual bytes, then 2-byte chunks, 
     * then 3-byte chunks, and so on...
     * At each test ensure that the same hash is generated.
     */
    for ( chunk_size = 1U; chunk_size < src_len; chunk_size++ )
    {
        mbedtls_sha3_init( &ctx );
        mbedtls_sha3_starts( &ctx, MBEDTLS_SHA3_224 );
        
        remaining = src_len;
        
        for ( i = 0U; i < src_len; i += chunk_size )
        {
            size_t len = ( remaining >= chunk_size ) ? chunk_size : remaining;
            
            mbedtls_sha3_update( &ctx, &src_str[i], len); 
            
            remaining -= len;
        }
        
        mbedtls_sha3_finish( &ctx, hash );
        
        TEST_ASSERT( memcmp( hash, reference_hash, 28U) == 0 );
    }
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_256_streaming( char *hex_src_string )
{
    mbedtls_sha3_context ctx;
    unsigned char reference_hash[129];
    unsigned char hash[129];
    unsigned char src_str[10000];
    size_t i;
    size_t chunk_size;
    size_t remaining;
    size_t src_len;
    
    memset(src_str, 0x00, 10000);
    memset(hash, 0x00, 129);
    memset(reference_hash, 0x00, 129);
    
    src_len = unhexify( src_str, hex_src_string );
    
    /* Generate a reference hash */
    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_256, reference_hash );
    
    /* Repeat each test with increasingly-sized data chunks 
     * E.g. start by processing bytes individual bytes, then 2-byte chunks, 
     * then 3-byte chunks, and so on...
     * At each test ensure that the same hash is generated.
     */
    for ( chunk_size = 1U; chunk_size < src_len; chunk_size++ )
    {
        mbedtls_sha3_init( &ctx );
        mbedtls_sha3_starts( &ctx, MBEDTLS_SHA3_256 );
        
        remaining = src_len;
        
        for ( i = 0U; i < src_len; i += chunk_size )
        {
            size_t len = ( remaining >= chunk_size ) ? chunk_size : remaining;
            
            mbedtls_sha3_update( &ctx, &src_str[i], len); 
            
            remaining -= len;
        }
        
        mbedtls_sha3_finish( &ctx, hash );
        
        TEST_ASSERT( memcmp( hash, reference_hash, 32U) == 0 );
    }
    
    mbedtls_sha3_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_384_streaming( char *hex_src_string )
{
    mbedtls_sha3_context ctx;
    unsigned char reference_hash[129];
    unsigned char hash[129];
    unsigned char src_str[10000];
    size_t i;
    size_t chunk_size;
    size_t remaining;
    size_t src_len;
    
    memset(src_str, 0x00, 10000);
    memset(hash, 0x00, 129);
    memset(reference_hash, 0x00, 129);
    
    src_len = unhexify( src_str, hex_src_string );
    
    /* Generate a reference hash */
    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_384, reference_hash );
    
    /* Repeat each test with increasingly-sized data chunks 
     * E.g. start by processing bytes individual bytes, then 2-byte chunks, 
     * then 3-byte chunks, and so on...
     * At each test ensure that the same hash is generated.
     */
    for ( chunk_size = 1U; chunk_size < src_len; chunk_size++ )
    {
        mbedtls_sha3_init( &ctx );
        mbedtls_sha3_starts( &ctx, MBEDTLS_SHA3_384 );
        
        remaining = src_len;
        
        for ( i = 0U; i < src_len; i += chunk_size )
        {
            size_t len = ( remaining >= chunk_size ) ? chunk_size : remaining;
            
            mbedtls_sha3_update( &ctx, &src_str[i], len); 
            
            remaining -= len;
        }
        
        mbedtls_sha3_finish( &ctx, hash );
        
        TEST_ASSERT( memcmp( hash, reference_hash, 48U) == 0 );
    }
    
    mbedtls_sha3_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C */
void mbedtls_sha3_512_streaming( char *hex_src_string )
{
    mbedtls_sha3_context ctx;
    unsigned char reference_hash[129];
    unsigned char hash[129];
    unsigned char src_str[10000];
    size_t i;
    size_t chunk_size;
    size_t remaining;
    size_t src_len;
    
    memset(src_str, 0x00, 10000);
    memset(hash, 0x00, 129);
    memset(reference_hash, 0x00, 129);
    
    src_len = unhexify( src_str, hex_src_string );
    
    /* Generate a reference hash */
    mbedtls_sha3( src_str, src_len, MBEDTLS_SHA3_512, reference_hash );
    
    /* Repeat each test with increasingly-sized data chunks 
     * E.g. start by processing bytes individual bytes, then 2-byte chunks, 
     * then 3-byte chunks, and so on...
     * At each test ensure that the same hash is generated.
     */
    for ( chunk_size = 1U; chunk_size < src_len; chunk_size++ )
    {
        mbedtls_sha3_init( &ctx );
        mbedtls_sha3_starts( &ctx, MBEDTLS_SHA3_512 );
        
        remaining = src_len;
        
        for ( i = 0U; i < src_len; i += chunk_size )
        {
            size_t len = ( remaining >= chunk_size ) ? chunk_size : remaining;
            
            mbedtls_sha3_update( &ctx, &src_str[i], len); 
            
            remaining -= len;
        }
        
        mbedtls_sha3_finish( &ctx, hash );
        
        TEST_ASSERT( memcmp( hash, reference_hash, 64U) == 0 );
    }
    
    mbedtls_sha3_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA1_C:MBEDTLS_SELF_TEST */
void sha1_selftest(  )
{
    TEST_ASSERT( mbedtls_sha1_self_test( 1 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA256_C:MBEDTLS_SELF_TEST */
void sha256_selftest(  )
{
    TEST_ASSERT( mbedtls_sha256_self_test( 1 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA512_C:MBEDTLS_SELF_TEST */
void sha512_selftest(  )
{
    TEST_ASSERT( mbedtls_sha512_self_test( 1 ) == 0 );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_SHA3_C:MBEDTLS_SELF_TEST */
void sha3_selftest()
{
    TEST_ASSERT( mbedtls_sha3_self_test( 0 ) == 0 );
}
/* END_CASE */
