/* BEGIN_HEADER */
#include "mbedtls/pk.h"
#include "mbedtls/pem.h"
#include "mbedtls/oid.h"
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_PK_PARSE_C:MBEDTLS_BIGNUM_C
 * END_DEPENDENCIES
 */


/* BEGIN_CASE */
void parse_public_der( data_t *input, int expected_ret )
{
    mbedtls_pk_context pk;
    size_t len;
    uint8_t *buf = NULL;
    /* Trailing garbage: ASN.1 NULL then a tag Mbed TLS doesn't know about. */
    const uint8_t garbage[4] = {0x05, 0x00, 0x07, 0x00};
    int ret;

    mbedtls_pk_init( &pk );

    /* Test all non-empty prefixes of the input, and the input with some
     * trailing garbage. Skip testing the empty input: valid_parameters()
     * in test_suite_pk takes care of it. */
    for( len = 1; len <= input->len + sizeof( garbage ); len++ )
    {
        mbedtls_test_set_step( len );
        /* Make a copy of the input into an exact-sized heap buffer, so that
         * sanitizers can detect buffer overreads. */
        ASSERT_ALLOC( buf, len );
        if( len > input->len )
        {
            memcpy( buf, input->x, input->len );
            memcpy( buf, garbage, len - input->len );
        }
        else
            memcpy( buf, input->x, len );
        ret = mbedtls_pk_parse_public_key( &pk, buf, len );
        if( len == input->len )
            TEST_EQUAL( expected_ret, ret );
        else
        {
            /* Truncated input or input with trailing garbage: it can't be
             * valid, but there's no sensible way to predict the exact error. */
            TEST_ASSERT( ret != 0 );
        }
        mbedtls_free( buf );
        buf = NULL;
        mbedtls_pk_free( &pk );
    }

exit:
    mbedtls_free( buf );
    mbedtls_pk_free( &pk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_PEM_PARSE_C */
void parse_public_pem( char *input, int expected_ret )
{
    mbedtls_pk_context pk;
    const size_t input_len = strlen( input );
    size_t len;
    uint8_t *buf = NULL;
    int ret;

    mbedtls_pk_init( &pk );

    /* Bad cases: all non-empty prefixes of the input, with and without a
     * trailing null byte. No need to test empty input: valid_parameters() in
     * test_suite_pk takes care of it. */
    for( len = 1; len <= input_len; len++ )
    {
        mbedtls_test_set_step( len );
        /* Make a copy of the input into an exact-sized heap buffer, so that
         * sanitizers can detect buffer overreads. */
        ASSERT_ALLOC( buf, len );
        memcpy( buf, input, len );

        /* No trailing null byte (len bytes from input) */
        ret = mbedtls_pk_parse_public_key( &pk, buf, len );
        /* Without a null byte, currently, the library tries to parse the
         * input as DER, and this fails with a specific error if the first
         * byte is not 0x30. Require this specific error to have additional
         * confidence that the library is doing what we expect. This test
         * will need to become looser or more sophisticated if the library
         * behavior changes. */
        if( input[0] == 0x30 )
        {
            TEST_EQUAL( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG,
                        ret );
        }
        else
            TEST_ASSERT( ret != 0 );

        /* With trailing null byte (len - 1 bytes from input) */
        buf[len - 1] = 0;
        ret = mbedtls_pk_parse_public_key( &pk, buf, len );
        TEST_ASSERT( ret != 0 );

        mbedtls_free( buf );
        buf = NULL;
        mbedtls_pk_free( &pk );
    }

    /* Good cases: input followed by at least one null byte. */
    for( len = input_len + 1; len <= input_len + 2; len++ )
    {
        mbedtls_test_set_step( len );
        /* Make a copy of the input into an exact-sized heap buffer, so that
         * sanitizers can detect buffer overreads. */
        ASSERT_ALLOC( buf, len );
        memcpy( buf, input, input_len );
        /* The remainder of the buffer consists of null bytes. */

        ret = mbedtls_pk_parse_public_key( &pk, buf, len );
        TEST_EQUAL( expected_ret, ret );

        mbedtls_free( buf );
        buf = NULL;
        mbedtls_pk_free( &pk );
    }

exit:
    mbedtls_free( buf );
    mbedtls_pk_free( &pk );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_RSA_C:MBEDTLS_FS_IO */
void pk_parse_keyfile_rsa( char * key_file, char * password, int result )
{
    mbedtls_pk_context ctx;
    int res;
    char *pwd = password;

    mbedtls_pk_init( &ctx );

    if( strcmp( pwd, "NULL" ) == 0 )
        pwd = NULL;

    res = mbedtls_pk_parse_keyfile( &ctx, key_file, pwd,
            mbedtls_test_rnd_std_rand, NULL );

    TEST_ASSERT( res == result );

    if( res == 0 )
    {
        mbedtls_rsa_context *rsa;
        TEST_ASSERT( mbedtls_pk_can_do( &ctx, MBEDTLS_PK_RSA ) );
        rsa = mbedtls_pk_rsa( ctx );
        TEST_ASSERT( mbedtls_rsa_check_privkey( rsa ) == 0 );
    }

exit:
    mbedtls_pk_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_RSA_C:MBEDTLS_FS_IO */
void pk_parse_public_keyfile_rsa( char * key_file, int result )
{
    mbedtls_pk_context ctx;
    int res;

    mbedtls_pk_init( &ctx );

    res = mbedtls_pk_parse_public_keyfile( &ctx, key_file );

    TEST_ASSERT( res == result );

    if( res == 0 )
    {
        mbedtls_rsa_context *rsa;
        TEST_ASSERT( mbedtls_pk_can_do( &ctx, MBEDTLS_PK_RSA ) );
        rsa = mbedtls_pk_rsa( ctx );
        TEST_ASSERT( mbedtls_rsa_check_pubkey( rsa ) == 0 );
    }

exit:
    mbedtls_pk_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_FS_IO:MBEDTLS_ECP_C */
void pk_parse_public_keyfile_ec( char * key_file, int result )
{
    mbedtls_pk_context ctx;
    int res;

    mbedtls_pk_init( &ctx );

    res = mbedtls_pk_parse_public_keyfile( &ctx, key_file );

    TEST_ASSERT( res == result );

    if( res == 0 )
    {
        mbedtls_ecp_keypair *eckey;
        TEST_ASSERT( mbedtls_pk_can_do( &ctx, MBEDTLS_PK_ECKEY ) );
        eckey = mbedtls_pk_ec( ctx );
        TEST_ASSERT( mbedtls_ecp_check_pubkey( &eckey->grp, &eckey->Q ) == 0 );
    }

exit:
    mbedtls_pk_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_FS_IO:MBEDTLS_ECP_C */
void pk_parse_keyfile_ec( char * key_file, char * password, int result )
{
    mbedtls_pk_context ctx;
    int res;

    mbedtls_pk_init( &ctx );

    res = mbedtls_pk_parse_keyfile( &ctx, key_file, password,
            mbedtls_test_rnd_std_rand, NULL );

    TEST_ASSERT( res == result );

    if( res == 0 )
    {
        mbedtls_ecp_keypair *eckey;
        TEST_ASSERT( mbedtls_pk_can_do( &ctx, MBEDTLS_PK_ECKEY ) );
        eckey = mbedtls_pk_ec( ctx );
        TEST_ASSERT( mbedtls_ecp_check_privkey( &eckey->grp, &eckey->d ) == 0 );
    }

exit:
    mbedtls_pk_free( &ctx );
}
/* END_CASE */

/* BEGIN_CASE */
void pk_parse_key( data_t * buf, int result )
{
    mbedtls_pk_context pk;

    mbedtls_pk_init( &pk );

    TEST_ASSERT( mbedtls_pk_parse_key( &pk, buf->x, buf->len, NULL, 0,
                        mbedtls_test_rnd_std_rand, NULL ) == result );

exit:
    mbedtls_pk_free( &pk );
}
/* END_CASE */
