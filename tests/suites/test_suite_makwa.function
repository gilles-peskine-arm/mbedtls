/* BEGIN_HEADER */
#include <string.h>
#include "mbedtls/base64.h"
#include "mbedtls/makwa.h"
#include "mbedtls/md.h"
/* END_HEADER */

/* BEGIN_DEPENDENCIES
 * depends_on:MBEDTLS_MAKWA_C
 * END_DEPENDENCIES
 */

/* BEGIN_CASE depends_on:MBEDTLS_GENPRIME */
void makwa_generate_modulus( int n_bits )
{
    mbedtls_mpi n1, n2, p, q;
    rnd_pseudo_info rnd1, rnd2;
    mbedtls_mpi_init( &n1 );
    mbedtls_mpi_init( &n2 );
    mbedtls_mpi_init( &p );
    mbedtls_mpi_init( &q );
    memset( &rnd1, 0, sizeof( rnd1 ) );
    memset( &rnd2, 0, sizeof( rnd2 ) );

    /* Run generate_modulus and generate_modulus_with_factors from the
     * same RNG and check that they produce the same n. */
    TEST_ASSERT( mbedtls_makwa_generate_modulus(
                     n_bits, &n1,
                     rnd_pseudo_rand, &rnd1 ) == 0 );
    TEST_ASSERT( mbedtls_makwa_generate_modulus_with_factors(
                     n_bits, &n2, &p, &q,
                     rnd_pseudo_rand, &rnd2 ) == 0 );
    TEST_ASSERT( mbedtls_mpi_cmp_mpi( &n1, &n2 ) == 0 );

    /* Check that n = p * q and that p and q look fine. */
    TEST_ASSERT( mbedtls_mpi_mul_mpi( &n2, &p, &q ) == 0 );
    TEST_ASSERT( mbedtls_mpi_cmp_mpi( &n1, &n2 ) == 0 );
    TEST_ASSERT( (int) mbedtls_mpi_bitlen( &p ) == n_bits / 2 );
    TEST_ASSERT( (int) mbedtls_mpi_bitlen( &q ) == n_bits / 2 );
    TEST_ASSERT( mbedtls_mpi_get_bit( &p, 0 ) == 1 );
    TEST_ASSERT( mbedtls_mpi_get_bit( &q, 0 ) == 1 );
    TEST_ASSERT( mbedtls_mpi_get_bit( &p, 1 ) == 1 );
    TEST_ASSERT( mbedtls_mpi_get_bit( &q, 1 ) == 1 );
    TEST_ASSERT( mbedtls_mpi_is_prime( &p, rnd_std_rand, NULL ) == 0 );
    TEST_ASSERT( mbedtls_mpi_is_prime( &q, rnd_std_rand, NULL ) == 0 );

exit:
    mbedtls_mpi_free( &n1 );
    mbedtls_mpi_free( &n2 );
    mbedtls_mpi_free( &p );
    mbedtls_mpi_free( &q );
}
/* END_CASE */

/* BEGIN_CASE */
void makwa_compute_raw( int md_alg_arg, int work_factor,
                        int pre_hash, int post_hash,
                        char *n_hex,
                        char *input_hex, char *salt_hex,
                        char *expected_output_hex )
{
    mbedtls_md_type_t md_alg = md_alg_arg;
    unsigned char input[300];
    size_t input_length;
    unsigned char salt[100];
    size_t salt_length;
    mbedtls_mpi n;
    unsigned char expected_output[600];
    unsigned char actual_output[600];
    size_t output_length;

    input_length = unhexify( input, input_hex );
    salt_length = unhexify( salt, salt_hex );
    output_length = unhexify( expected_output, expected_output_hex );
    mbedtls_mpi_init( &n );
    TEST_ASSERT( mbedtls_mpi_read_string( &n, 16, n_hex ) == 0 );

    TEST_ASSERT( mbedtls_makwa_compute_raw( md_alg, &n, work_factor,
                                            pre_hash, post_hash,
                                            input, input_length,
                                            salt, salt_length,
                                            actual_output,
                                            output_length ) == 0 );
    TEST_ASSERT( memcmp( actual_output, expected_output,
                         output_length ) == 0 );

exit:
    mbedtls_mpi_free( &n );
}
/* END_CASE */

/* BEGIN_CASE */
void makwa_verify_raw( int md_alg_arg, int work_factor,
                       int pre_hash, int post_hash,
                       char *n_hex,
                       char *input_hex, char *salt_hex,
                       char *expected_output_hex,
                       int expected_status )
{
    mbedtls_md_type_t md_alg = md_alg_arg;
    unsigned char input[300];
    size_t input_length;
    unsigned char salt[100];
    size_t salt_length;
    mbedtls_mpi n;
    unsigned char expected_output[600];
    size_t output_length;

    input_length = unhexify( input, input_hex );
    salt_length = unhexify( salt, salt_hex );
    output_length = unhexify( expected_output, expected_output_hex );
    mbedtls_mpi_init( &n );
    TEST_ASSERT( mbedtls_mpi_read_string( &n, 16, n_hex ) == 0 );

    /* Test correct output */
    TEST_ASSERT( mbedtls_makwa_verify_raw(
                     md_alg, &n, work_factor, pre_hash, post_hash,
                     input, input_length, salt, salt_length,
                     expected_output,
                     output_length ) == expected_status );

exit:
    mbedtls_mpi_free( &n );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BASE64_C */
void makwa_compute_base64( int md_alg_arg, int work_factor,
                           int pre_hash, int post_hash,
                           char *n_hex,
                           char *input_hex, char *salt_hex,
                           int output_length,
                           char *expected_output )
{
    mbedtls_md_type_t md_alg = md_alg_arg;
    unsigned char input[300];
    size_t input_length;
    unsigned char salt[100];
    size_t salt_length;
    mbedtls_mpi n;
    char actual_output[800];

    input_length = unhexify( input, input_hex );
    salt_length = unhexify( salt, salt_hex );
    mbedtls_mpi_init( &n );
    TEST_ASSERT( mbedtls_mpi_read_string( &n, 16, n_hex ) == 0 );

    TEST_ASSERT( mbedtls_makwa_compute_base64(
                     md_alg, &n, work_factor,
                     pre_hash, post_hash,
                     input, input_length,
                     salt, salt_length,
                     output_length,
                     actual_output, sizeof( actual_output ) ) == 0 );
    TEST_ASSERT( strcmp( actual_output, expected_output ) == 0 );

exit:
    mbedtls_mpi_free( &n );
}
/* END_CASE */

/* BEGIN_CASE depends_on:MBEDTLS_BASE64_C */
void makwa_verify_base64( int md_alg_arg, char *n_hex,
                          char *input_hex, char *expected_output,
                          int expected_status )
{
    mbedtls_md_type_t md_alg = md_alg_arg;
    unsigned char input[300];
    size_t input_length;
    mbedtls_mpi n;

    input_length = unhexify( input, input_hex );
    mbedtls_mpi_init( &n );
    TEST_ASSERT( mbedtls_mpi_read_string( &n, 16, n_hex ) == 0 );

    /* If the first character of the work factor exponent (delta) is '?'",
     * calculate the work factor from platform data. */
    if( expected_output[14] == '?' )
    {
        mbedtls_makwa_work_factor_t w;
        unsigned delta = 0;
        switch( expected_output[15] )
        {
            case '^':
                /* Smallest delta that overflows mbedtls_makwa_work_factor_t. */
                for( w = -1; w >= 3; w >>= 1 )
                    ++delta;
                break;
            default:
                TEST_ASSERT( ! "Unsupported work factor substitution" );
        }
        expected_output[14] = '0' + delta / 10;
        expected_output[15] = '0' + delta % 10;
    }

    TEST_ASSERT( mbedtls_makwa_verify_base64(
                     md_alg, &n,
                     input, input_length,
                     expected_output ) == expected_status );

exit:
    mbedtls_mpi_free( &n );
}
/* END_CASE */
